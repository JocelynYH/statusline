# Original theme agnoster, in oh-my-zsh (https://github.com/robbyrussell/oh-my-zsh)
# Forked from https://gist.github.com/smileart/3750104
# This mod is located here: https://github.com/el1t/agnostermod/

ZSH_THEME_GIT_PROMPT_DIRTY=' ±'
STATUSBAR_LENGTH=12	# Initialize with default number of spaces/symbols in prompt

# Global vars/constants
CURRENT_BG='NONE'
MIDDLE_BG='white'
SEGMENT_SEPARATOR=''
SEGMENT_SEPARATOR_RIGHT=''
SEGMENT_SEPARATOR_LIGHT=''
SEGMENT_SEPARATOR_LIGHT_RIGHT=''
STATUS_EVAL='%(?..%{%F{red}%}✘)'

### Segment drawing
# A few utility functions to make it easy and re-usable to draw segmented prompts

# Begin a segment
# Takes two arguments, background and foreground. Both can be omitted,
# rendering default background/foreground.
function prompt_segment() {
	local bg fg
	[[ -n $1 ]] && bg="%K{$1}" || bg="%k"
	[[ -n $2 ]] && fg="%F{$2}" || fg="%f"
	if [[ $CURRENT_BG != "NONE" ]]; then
		if [[ $1 != $CURRENT_BG ]]; then
			echo -n " %{$bg%F{$CURRENT_BG}%}$SEGMENT_SEPARATOR "
		else
			# Color 15 should be the terminal background color
			echo -n " %{$bg%F{15}%}$SEGMENT_SEPARATOR_LIGHT "
		fi
	else
		echo -n "%{$bg%} "
	fi
	CURRENT_BG=$1
	[[ -n $3 ]] && echo -n "%{$fg%}$3" || echo -n "%{$fg%}"
}

# End the prompt, closing any open segments
function prompt_end() {
	[[ -n $MIDDLE_BG ]] && MIDDLE_BG="%K{$MIDDLE_BG%}" || MIDDLE_BG="%k"
	if [[ -n $CURRENT_BG ]]; then
		echo -n " %{%F{$CURRENT_BG}$MIDDLE_BG%}$SEGMENT_SEPARATOR"
	else
		echo -n "%{$MIDDLE_BG%}"
	fi
	echo -n "%{%f%}"
}

# Set the bg color for rprompt
function prompt_start() {
	echo -n "%{${${MIDDLE_BG:+%K{$MIDDLE_BG}}:-%k}%}"
	CURRENT_BG=$MIDDLE_BG
}

# Begin a segment in rprompt
function right_prompt_segment() {
	local bg fg bbg
	if [[ -n $1 ]]; then
		bg="%K{$1}"
		bbg="%F{$1}"
	else
		bg="%k"
		bbg="%f"
	fi
	[[ -n $2 ]] && fg="%F{$2}" || fg="%f"
	if [[ $1 != $CURRENT_BG ]]; then
		echo -n " %{$bbg%}$SEGMENT_SEPARATOR_RIGHT%{$bg$fg%} "
	else
		# Color 15 should be the terminal background color
		echo -n " %{$bg%F{15}%}$SEGMENT_SEPARATOR_LIGHT_RIGHT%{$fg%} "
	fi
	CURRENT_BG=$1
	[[ -n $3 ]] && echo -n "$3"
}

# Pad background for tmux prompt manually, due to lack of %E support
function prompt_tmux_padding() {
	if [[ -n $TMUX ]]; then
		echo -n "%K{white}${(l:$COLUMNS:: :)}%{$(echotc LEFT $COLUMNS)%}"
	fi
}

### Prompt components
# Each component will draw itself, and hide itself if no information needs to be shown

# Status: root/error/background jobs
function prompt_status() {
	local symbols="%(#.%{%F{yellow}%}⚡.)$RETVAL"
	[[ -n "$(jobs -l)" ]] && symbols+="%{%F{cyan}%}⚙"
	symbols="${(%):-$symbols}"

	if [[ -n $symbols ]]; then
		prompt_segment black default $symbols
		(( STATUSBAR_LENGTH += $#symbols + 3 ))
	fi
}

# Virtualenv: current working virtualenv
# function prompt_virtualenv() {
# 	local virtualenv_path="$VIRTUAL_ENV"
# 	if [[ -n $virtualenv_path && -n $VIRTUAL_ENV_DISABLE_PROMPT ]]; then
# 		local output = "(`basename $virtualenv_path`)"
# 		prompt_segment green black $output
# 		(( STATUSBAR_LENGTH += $#output ))
# 	fi
# }

# User: username
function prompt_user() {
	if [[ $USER != $DEFAULT_USER || -n $SSH_CLIENT ]]; then
		prompt_segment black yellow $USER
		(( STATUSBAR_LENGTH += $#USER ))
	fi
}

# Machine: machine name
function right_prompt_machine() {
	 if [[ -n $SSH_CLIENT ]]; then
		right_prompt_segment yellow black "@%m"
	 fi
}

# Git: branch, dirty status, commits behind/ahead of remote
function prompt_git() {
	if [[ -n $git_info ]]; then
		# Declaring this inside the if statement would not be local
		local git_output="${(e)git_info[prompt]}"
		if [[ -n $git_output ]]; then
			prompt_segment "${git_info[bg]}" "${git_info[untracked]:+white}" $git_output
			(( STATUSBAR_LENGTH += $#git_output + 2 ))
		fi
	fi
}

function right_prompt_git() {
	if [[ -n $git_info ]]; then
		local git_output="${git_info[rprompt]}"
		if [[ -n $git_output ]]; then
			case "${git_info[action]}" in
				(apply)
					right_prompt_segment white black "<A<"
					;;
				(bisect)
					right_prompt_segment white black "<B>"
					;;
				(cherry-pick|cherry-pick-sequence)
					right_prompt_segment white black "<C<"
					;;
				(merge)
					right_prompt_segment white black ">M<"
					;;
				(rebase|rebase-interactive|rebase-merge)
					right_prompt_segment white black ">R>"
					;;
			esac
			right_prompt_segment white black $git_output
		fi
	fi
}

# Dir: current working directory, shortens if longer than available space
function prompt_dir {
	local directory="${${(%):-%~}[2,-1]}"
	local hashed_directory="${${directory%%/*}:-${${(%):-%~}[1]}}"
	prompt_segment blue white $hashed_directory
	(( STATUSBAR_LENGTH += $#hashed_directory + 2 ))
	# Replace directory with empty string if at base of hashed directory, else eliminate hashed portion
	directory="${${directory:#^*/*}:+${directory#*/}}"
	if [[ -n $directory ]]; then
		local termwidth=$(helper_count_spacing)
		if [[ $#directory -gt $termwidth ]]; then
			prompt_segment blue white "%${termwidth}<…<%~%<<"
		else
			prompt_segment blue white $directory
		fi
	fi
	# ${param:-value} means use param if non-zero length, else value
	# (%) means expand % params
	# ${(C)__string__} capitalizes the first character of each word, zsh style
}

# Helper function: count the spaces available for printing the working directory
function helper_count_spacing {
	# Returns exit code 0 if $SSH_TTY exists
	[[ -n $SSH_TTY ]]
	# Store substituted string of trimmed time, history count, and machine name depending on previous exit code
	local temp="${${(%):-%t%!%(?.⮂ @%m .)}## }"
	# From the total width, subtract spaces, left-side length without working directory, (trimmed) time + space, and history count
	echo $(( $COLUMNS - $STATUSBAR_LENGTH - $#temp - 1 ))
}

function statusbar_left() {
	RETVAL="${(%):-$STATUS_EVAL}"
	CURRENT_BG='NONE'
	prompt_tmux_padding
	prompt_status
	# prompt_virtualenv
	prompt_user
	prompt_git
	prompt_dir
	prompt_end
	# Clear to EOL if not in tmux
	[[ -z $TMUX ]] && echo -n "%E"
}

function statusbar_right() {
	prompt_start
	right_prompt_git
	# print time, trimming leading spaces
	right_prompt_segment magenta white "${${(%):-%t}## }"
	# print history number
	right_prompt_segment white black "!%{%F{blue}%}%!"
	right_prompt_machine
}

function prompt_style() {
	zstyle ':prezto:module:editor:info:completing' format '%B%F{red}...%f%b'
	zstyle ':prezto:module:editor:info:keymap:primary' format ' %B%F{red}❯%F{yellow}❯%F{green}❯%f%b'
	zstyle ':prezto:module:editor:info:keymap:primary:overwrite' format ' %F{red}♺%f'
	zstyle ':prezto:module:editor:info:keymap:alternate' format ' %B%F{green}❮%F{yellow}❮%F{red}❮%f%b'

	zstyle ':prezto:module:git:info' verbose 'yes'
	zstyle ':prezto:module:git:info:action' format '%s'
	zstyle ':prezto:module:git:info:added' format '%F{green}✚%f'
	zstyle ':prezto:module:git:info:ahead' format '%F{yellow}↑%A%f'
	zstyle ':prezto:module:git:info:behind' format '%F{yellow}↓%B%f'
	zstyle ':prezto:module:git:info:branch' format ' %b'
	zstyle ':prezto:module:git:info:commit' format '%.7c'
	zstyle ':prezto:module:git:info:deleted' format '%F{red}✖%f'
	zstyle ':prezto:module:git:info:modified' format 'yellow'
	zstyle ':prezto:module:git:info:position' format ':%p'
	zstyle ':prezto:module:git:info:renamed' format '%F{9}➜%f'
	zstyle ':prezto:module:git:info:stashed' format '%F{cyan}§%f'
	zstyle ':prezto:module:git:info:unmerged' format '%F{yellow}₥%f'
	zstyle ':prezto:module:git:info:untracked' format 'red'
	zstyle ':prezto:module:git:info:keys' format \
		'prompt' '$(coalesce "%b" "%p" "%c")%s' \
		'rprompt' '%A%B%S%a%d%r%U' \
		'bg' '$(coalesce "%u" "%m" "green")' \
		'untracked' '%u'
}

# ${var} and $(method) are different!!
# %b = , %f = default foreground, %k = default background
# %B = , %F = fg (text) color, %K = bg color, %E = clear to end of line

## Main prompt
function prompt_agnostermod_precmd() {
	if (( $+functions[git-info] )); then
		git-info
	fi
}

function prompt_agnostermod_setup() {
	setopt LOCAL_OPTIONS
	unsetopt XTRACE KSH_ARRAYS
	prompt_opts=(cr percent subst)

	autoload -Uz add-zsh-hook
	add-zsh-hook precmd prompt_agnostermod_precmd

	prompt_style

	# Set primary prompt
	PROMPT='%{%f%k%b%}
$(statusbar_left)
%{%F{blue}%K{white}%}❯%{%k%F{white}%}$SEGMENT_SEPARATOR%{%f%b%}'
	RPROMPT='%{$(echotc UP 1)%}$(statusbar_right)%{$(echotc DO 1)%}'

	# Secondary prompt, printed when the shell needs more information to complete a command
	PS2='%{%F{cyan}%K{white}%}❯%{%k%F{white}%}$SEGMENT_SEPARATOR%{%f%b%}'
	RPS2='%{%k%F{white}%}$SEGMENT_SEPARATOR_RIGHT%{%F{cyan}%K{white}%} %_%E'

	# Selection prompt used within a select loop
	PS3='%{%F{13}%K{white}%} Select: %{%F{white}%k%}⮀%{%f%} '

	# Execution trace prompt
	# setopt xtrace # disable with unsetopt xtrace
	PS4='%{%K{white}%} %{%F{green}%}%N%{%f%}:%{%F{blue}%}%i %{%F{white}%k%}⮀%{%f%} '
}

prompt_agnostermod_setup "$@"
